# üß† Intelligent Graph Editor

A modular, data-agnostic visual graph editor for knowledge modeling, reasoning, planning, and exploration. It combines structured and unstructured data with visual intelligence powered by LLMs and semantic inference. Designed to serve diverse use cases‚Äîsuch as career coaching, curriculum planning, knowledge discovery, and narrative design‚Äîit is extensible, collaborative, and AI-enhanced.

---

## üß≠ Interface Layout

The editor consists of three primary regions:

### üîç Left Panel: Data Library
This is where the user manages their available datasets, including structured (CSV, JSON) and unstructured (text, logs, markdown, transcripts) inputs. Data entries are categorized and presented as draggable items.

- Datasets are imported from local files or integrated sources such as APIs, Obsidian vaults, Notion, or Supabase.
- LLM-enhanced tools can parse documents or freeform text into nodes and suggested structures.
- Items in the library are typed and filterable, allowing users to identify goals, skills, courses, or events quickly.

### üéØ Middle Panel: Graph Canvas
This is the visual workspace where users compose and interact with their knowledge graph.

- Nodes can be created by dragging from the left or through AI-assisted suggestions.
- When multiple nodes are related (by rules or embedding similarity), edges are either auto-created or suggested.
- Edges are semantically typed (e.g., "requires", "causes", "contradicts") and styled accordingly.
- Layout controls include zoom, pan, minimap, and multiple view modes:
  - Reasoning Mode (shows inferred nodes)
  - Timeline Mode (shows chronological structure)
  - Cluster Mode (grouped by similarity or tags)
  - Draft Mode (see unpublished or in-progress items)

Graph interactions include right-click context menus with AI tools:
- ‚ú® "Explain Connection": Uses GPT to explain the meaning between two nodes.
- ü§ñ "Suggest What's Missing": Suggests intermediate or connected concepts.
- üîç "Trace Reasoning Path": Visualizes how one concept leads to another.

### üßæ Right Panel: Inspector & Group Analytics
This side panel shows contextual details about selected nodes or groups.

When a single node is selected:
- Type, label, description, embedding vector (if available)
- Inline markdown or JSON editor
- Node relationships and metadata

When multiple nodes are selected:
- Shared traits and themes
- Similarity score matrix (cosine similarity)
- Contradictions or gaps detected between them
- GPT-powered summary of the group
- Grouping tools to form meta-nodes or logical clusters

---

## üîÑ Semantic Linking and Cosine Similarity

To enable intelligent connection of related nodes, the system uses embedding vectors generated by models like OpenAI's `text-embedding-3-small` or local Sentence Transformers.

1. When a new node is created, its label and description are embedded.
2. All existing nodes are compared to this vector using cosine similarity.
3. If similarity exceeds a configurable threshold, related nodes are suggested.
4. Users can:
   - Auto-link (if enabled)
   - Manually approve links
   - Inspect why two nodes are semantically close (via "Explain Connection")

Embeddings are cached and stored alongside nodes, enabling fast comparisons.

---

## üß† Reasoning Tools and Causal Logic

The system is built to model not only relationships, but **reasoning**:

- **Truth Table Editor**: Condition nodes can store logical tables (e.g., if Skill A and Skill B, then qualify for Job X).
- **Probability Sliders**: For modeling uncertainty and Bayes-style reasoning.
- **Conflict Detection**: Nodes or edges that contradict each other (e.g., mutually exclusive skills) are flagged.
- **Sequence Mapping**: Users can assign time steps, delays, or dependencies between events.

These features turn the graph into a semi-formal knowledge model suitable for tutoring systems, simulations, and goal planning.

---

## ‚ú® AI & LLM Integration

This graph editor is deeply enhanced by GPT tools. LLMs can:

- Convert text into nodes with inferred types (goal, skill, course, etc.)
- Suggest what to add next based on graph content
- Justify why nodes are connected or grouped
- Generate summaries for node clusters or branches
- Answer questions grounded in the graph (e.g., "What jobs align with these three skills?")

The right-click menu and sidebar are entry points for these AI actions.

---

## ‚úèÔ∏è Authoring & Usability Features

- **Draft vs Committed Nodes**: Drafts appear translucent. Committing them confirms their role in the model.
- **Undo/Redo**: Graph actions are tracked for easy iteration.
- **Sticky Notes**: Designers and collaborators can leave free-floating thoughts.
- **Timelapse Replay**: Visualize how the graph evolved over time.
- **Keyboard Navigation**: Navigate through connected nodes with arrow keys or hotkeys.

---

## üé® Visual Design & Customization

- **Node Shapes**: Vary by type‚Äîe.g., circle for outcomes, square for concepts, triangle for triggers.
- **Color Gradients**: Represent recency, frequency, or confidence.
- **Edge Types**: Solid for explicit, dashed for inferred, animated for dynamic relationships.
- **Labels & Media**: Inline edge labels ("causes", "depends on"). Nodes can include icons, images, and audio.

---

## üîå Data Interoperability & External Sources

- **Import**:
  - Structured: CSV, JSON, OWL/RDF
  - Unstructured: Markdown, essays, transcripts
  - API or real-time data feeds

- **Export**:
  - Graph images (PNG, SVG)
  - Summary PDFs with graph content
  - Mindmap and JSON format for downstream tools

---

## üîê Sharing, Versioning, and Collaboration

- **Live Editing**: Optional real-time collaboration (e.g., with Supabase or Firebase)
- **Forking and Merging**: Clone graphs and merge branches with visual diffing
- **Pinned Views**: Save and restore filtered visual states
- **Session Saving**: Save entire workspaces including layout, selected tools, and loaded data

---

## üöß Implementation Notes

- Built with **React**, **Zustand**, and **React Flow**.
- Embeddings retrieved via OpenAI or local SentenceTransformers.
- Semantic logic handled in `semanticLinker.ts`, using cosine similarity.
- Visual schema-driven system allows per-node-type rendering, validation, and rules.

---

## ‚úÖ Next Steps

- Integrate dataset manager on the left panel with drag-and-drop preview.
- Build embedding service and connection suggestion module.
- Create modal tools for GPT actions (summarize, suggest, trace).
- Expand condition logic system for more powerful cause-effect modeling.
- Finalize plugin system and view mode switcher.

This system is not just a graph editor‚Äîit‚Äôs an **intelligent thinking canvas**, ready to support speculative reasoning, visual planning, and deep personalization.

